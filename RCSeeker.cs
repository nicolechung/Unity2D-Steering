// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
using UnityEngine;
using System.Collections;
using System.Collections.Generic;

// trying out wandering with raycasting and update
public class RCSeeker : MonoBehaviour
{
	
	
		public float collisionDistance = 2;
		public float speed = 1;
		private float direction;
		public GameObject Target;
		public bool LockToCameraViewport;
		private float viewportWidth;
		private float viewportHeight;
		private Bounds cameraBounds;
		private string state;
		private bool hasHitTarget;
		private static bool DEBUG = true;
		private static bool DEBUG_DRAW = true;
		private List<Vector2> directions;
		private float rotationRange = 2;

	
		// todo: store am array of directions
		Vector2 origin;
	
	
		// Use this for initialization
		void Start ()
		{
				// start out seeking if the Target is within range
				state = "seek";
				hasHitTarget = false;
				directions = new List<Vector2> ();
				StartCoroutine (Seek ());
		
		}
	
		void OnCollisionEnter2D (Collision2D col)
		{
		
				if (col.gameObject.name == "Player") {
						hasHitTarget = true;
				}
		}
	
		IEnumerator Seek ()
		{
				// check if there is something in the way of the target
		
				while (!hasHitTarget && state=="seek") {
						bool seek;
						seek = seekCheck ();
						if (DEBUG) Debug.Log ("seeking: seek?");
						if (DEBUG) Debug.Log (seek);
						if (seek) {	
								transform.Translate (Vector2.up * speed * Time.smoothDeltaTime);
						} else {
								state = "start-rotate";
						}
						yield return null;
				}
		}
	
		IEnumerator AvoidMove ()
		{
				if (DEBUG) Debug.Log ("--moving around obstacle--");
				bool obstacle;
				bool seek;
		
				while (state=="avoid") {
						// check if there is something in the way of the target
						transform.Translate (Vector2.up * speed * Time.smoothDeltaTime);
						seek = seekCheck ();
						obstacle = obstacleCheck ();
						if (DEBUG) Debug.Log ("--is there an obstacle?--");
						if (DEBUG) Debug.Log (obstacle);
						if (DEBUG) Debug.Log ("avoiding state, keep seeking?");
						if (DEBUG) Debug.Log (seek);
			
						// inside here, if there is an obstacle, change state to "rotate"
						if (obstacle) {
								state = "start-rotate";
								yield return null;
						}
						// else start seek
						if (seek && !obstacle) {
								Debug.Log ("--starting seek--");
								state = "seek";
								StartCoroutine (Seek ());
						} 
						transform.Translate (Vector2.up * speed * Time.smoothDeltaTime);
			
						yield return null;
				}
		
		}
	
		bool hasObstacles (Vector2 direction, string colorString)
		{
				RaycastHit2D[] hits;
				RaycastHit2D[] hitsLeft;
				RaycastHit2D[] hitsRight;
		
		
				Vector2 directionLeft;

				Vector2 directionRight;
				// move the origin of the Raycast so that it's outside of the collider

				Color color;
				// move the origin of the Raycast so that it's outside of the collider
		
				switch (colorString) {
				case "blue":
						color = Color.cyan;
						break;
			
				case "red":
						color = Color.red;
						break;
			
				case "yellow":
						color = Color.yellow;
						break;
			
				default:
						color = Color.black;
						break;
				}
		
				bool hasObstacle = false;
				if (DEBUG_DRAW) Debug.DrawRay (transform.position, direction * collisionDistance, color);
		
				hits = Physics2D.RaycastAll (transform.position, direction, collisionDistance, 1 << 8);
		
				Vector2 left = new Vector2 (-0.3F, 0);
				Vector2 leftOrigin = new Vector2 (transform.position.x, transform.position.y) + left;
				directionLeft = direction + left;
				hitsLeft = Physics2D.RaycastAll (leftOrigin, directionLeft, collisionDistance, 1 << 8);
				if (DEBUG_DRAW) Debug.DrawRay (leftOrigin, directionLeft * collisionDistance, color);
		
				Vector2 right = new Vector2 (0.3F, 0);
				Vector2 rightOrigin = new Vector2 (transform.position.x, transform.position.y) + right;
				directionRight = direction + right;
				hitsRight = Physics2D.RaycastAll (rightOrigin, directionRight, collisionDistance, 1 << 8);
				if (DEBUG_DRAW) Debug.DrawRay (rightOrigin, directionRight * collisionDistance, color);
				// is there a collision?
		
				foreach (RaycastHit2D hit in hits) {
						if (hit && hit.collider) {
								hasObstacle = true;
						}
				}
		
				foreach (RaycastHit2D hit in hitsLeft) {
						if (hit && hit.collider) {
								hasObstacle = true;
						}
				}
		
				foreach (RaycastHit2D hit in hitsRight) {
						if (hit && hit.collider) {
								hasObstacle = true;
						}
				}
		
				return hasObstacle;
		}
	
		bool seekCheck ()
		{
		
				if (state == "seek") {
						float zRotation = Mathf.Atan2 ((Target.transform.position.y - transform.position.y), (Target.transform.position.x - transform.position.x)) * Mathf.Rad2Deg - 90;
						transform.eulerAngles = new Vector3 (0, 0, zRotation);
				}
		
				Vector2 direction = (Target.transform.position - transform.position).normalized;
		
				bool hasObstacle = hasObstacles (direction, "blue");
		
				return !hasObstacle;
		
		}
	
		bool obstacleCheck ()
		{
				Vector2 direction;
				direction = transform.up;
				bool hasObstacle = hasObstacles (direction, "yellow");

		
				return hasObstacle;
		}
	
	
		// need optional last direction
	
		IEnumerator rotateAround ()
		{
				while (state=="rotate") {
						// save randomAngle in a array
						if (DEBUG) Debug.Log ("--state: rotate--");
						float randomAngle = Random.Range (-rotationRange, rotationRange);
						Vector2 directionChange = new Vector2 (randomAngle, 0);
						Vector2 originalDirection;
						Vector2 direction;
						bool obstacle;
						// todo: save direction and cache it
						if (directions.Count == 0) {
							originalDirection = Target.transform.position;
							direction = originalDirection + directionChange;
							obstacle = hasObstacles (direction, "yellow");
							if (DEBUG) Debug.Log ("---obstacle?:---");
							if (DEBUG) Debug.Log (obstacle);
							if (!obstacle) {
								if (DEBUG) Debug.Log ("---no obstacle, moving:---");
								float zRotation = Mathf.Atan2 ((direction.y - transform.position.y), (direction.x - transform.position.x)) * Mathf.Rad2Deg - 90;
								transform.eulerAngles = new Vector3 (0, 0, zRotation);
								// clear the rotations list
								directions.Clear ();
								// if there is no obstacle, then actually rotate in that direction
								state = "start-move";
							} else {
								directions.Add (direction);
								yield return null;
								
							}
					} else {
				// loop through the list of directions
							foreach (Vector2 element in directions) {
								originalDirection = element;
							}
						}
						
						direction = originalDirection + directionChange;
			
						// choose a random direction and do an obstacle check in that direction
						obstacle = hasObstacles (direction, "yellow");
						if (DEBUG) Debug.Log ("---obstacle?:---");
						if (DEBUG) Debug.Log (obstacle);
						if (!obstacle) {
								if (DEBUG) Debug.Log ("---no obstacle, moving:---");
								float zRotation = Mathf.Atan2 ((direction.y - transform.position.y), (direction.x - transform.position.x)) * Mathf.Rad2Deg - 90;
								transform.eulerAngles = new Vector3 (0, 0, zRotation);
								// clear the rotations list
								directions.Clear ();
								// if there is no obstacle, then actually rotate in that direction
								state = "start-move";
						} else {
								directions.Add (direction);
								yield return null;
				
						}
				}

		}
	
	
	
	
		// Update is called once per frame
		void Update ()
		{
		
				switch (state) {
				case "seek":
			
						break;
			
				case "start-move":
						state = "avoid";
						StartCoroutine (AvoidMove ());
			
						break;
		

				case "start-rotate":
						state = "rotate";
						StartCoroutine (rotateAround ());
						break;
			
				default: 
			
						break;
				}
		
		}
	
	
		// helpers
	
		bool CheckRange (float num, float min, float max)
		{
				return num > min && num < max;
		}
	
}